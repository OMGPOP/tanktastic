// Generated by CoffeeScript 1.3.3
(function() {
  var Game, Tank;

  Game = (function() {

    function Game(tanks, dt) {
      this.tanks = tanks;
      this.dt = dt;
      this.bullets = [];
      this.dt2 = this.dt * this.dt;
      this.r = 300;
    }

    Game.prototype.init = function() {
      var tank, _i, _len, _ref, _results;
      _ref = this.tanks;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        tank = _ref[_i];
        _results.push(tank.init(this.tanks.length - 1));
      }
      return _results;
    };

    Game.prototype.step = function() {
      var tank, tanks, _i, _len;
      tanks = this.tanks.filter(function(tank) {
        return tank.life > 0;
      });
      if (tanks.length < 2) {
        end_game();
      }
      for (_i = 0, _len = tanks.length; _i < _len; _i++) {
        tank = tanks[_i];
        tank.step(this.dt, tank.to_state(), radar(tank, tanks));
      }
      fire(tanks);
      integrate(tanks);
      resolve_collisons(tanks);
      return this.bullets = this.bullets.filter(function(bullet) {
        return !bullet.dead;
      });
    };

    Game.prototype.radar = function(tank, tanks) {
      var t, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = tanks.length; _i < _len; _i++) {
        t = tanks[_i];
        if (t !== tank) {
          _results.push({
            x: t.x,
            y: t.y
          });
        }
      }
      return _results;
    };

    Game.prototype.integrate = function(tanks) {
      var bullet, tank, _i, _j, _len, _len1, _results;
      for (_i = 0, _len = bullets.length; _i < _len; _i++) {
        bullet = bullets[_i];
        bullet.x += bullet.vx * this.dt;
        bullet.y += bullet.vy * this.dt;
      }
      _results = [];
      for (_j = 0, _len1 = tanks.length; _j < _len1; _j++) {
        tank = tanks[_j];
        tank.fx -= tank.vx * 0.03;
        tank.fy -= tank.vy * 0.03;
        tank.vx += tank.fx * this.dt;
        tank.vy += tank.fy * this.dt;
        tank.x += tank.vx * this.dt + tank.fx * this.dt2;
        _results.push(tank.y += tank.vy * this.dt + tank.fy * this.dt2);
      }
      return _results;
    };

    Game.prototype.fire = function(tanks) {
      var bullet, tank, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = tanks.length; _i < _len; _i++) {
        tank = tanks[_i];
        if (tank.gun_heat <= tank.fire_command) {
          bullet = new Bullet(tank, tank.fire_command, tank.x, tank.y, tank.fx, tank.fy);
          tank.gun_heat += tank.fire_command;
          _results.push(this.bullets.push(bullet));
        } else {
          _results.push(tank.gun_heat -= this.dt);
        }
      }
      return _results;
    };

    Game.prototype.resolve_collisions = function() {
      var bullet, dx, dy, tank, _i, _j, _len, _len1, _ref, _results;
      _results = [];
      for (_i = 0, _len = bullets.length; _i < _len; _i++) {
        bullet = bullets[_i];
        _ref = this.tanks;
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          tank = _ref[_j];
          if (bullet.tank !== tank) {
            dx = bullet.x - tank.x;
            dy = bullet.y - tank.y;
            if (dx * dx + dy * dy < tank.r * tank.r + bullet.r * bullet.r) {
              bullet.dead = true;
              tank.life -= bullet.power;
              bullet.tank.score += bullet.power;
              break;
            }
          }
        }
        if (bullet.x * bullet.x + bullet.y * bullet.y >= this.r) {
          _results.push(bullet.dead = true);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Game.prototype.end_game = function() {
      return alert("End of game.");
    };

    return Game;

  })();

  Tank = (function() {

    function Tank() {}

    Tank.prototype.to_state = function(opponents, r) {
      var _this = this;
      this.fx = this.fy = 0.0;
      return {
        x: this.x,
        y: this.y,
        radius: this.r,
        vx: this.vx,
        vy: this.vy,
        turn: function(bearing) {
          return _this.theta += bearing;
        },
        apply: function(fx, fy) {
          _this.fx += fx;
          return _this.fy += fy;
        },
        fire: function(power) {
          return _this.fire_command = Math.min(Math.max(0.1, power), 5.0);
        },
        theta: this.theta,
        radar: opponents,
        arena_radius: r,
        gun_heat: this.gun_heat,
        life: this.life,
        score: this.score
      };
    };

    return Tank;

  })();

}).call(this);
