// Generated by CoffeeScript 1.3.3
(function() {
  var Game, Tank;

  Game = (function() {

    function Game(tanks, dt) {
      this.tanks = tanks;
      this.dt = dt;
      this.bullets = [];
      this.dt2 = this.dt * this.dt;
      this.r = 300;
    }

    Game.prototype.init = function() {
      var tank, _i, _len, _ref, _results;
      _ref = this.tanks;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        tank = _ref[_i];
        _results.push(tank.init);
      }
      return _results;
    };

    Game.prototype.step = function() {
      var tank, _i, _len, _ref;
      _ref = this.tanks;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        tank = _ref[_i];
        tank.step(this.dt, tank.state, radar);
      }
      fire();
      integrate();
      resolve_collisons();
      this.tanks = this.tanks.filter(function(tank) {
        return tank.life > 0;
      });
      this.bullets = this.bullets.filter(function(bullet) {
        return !bullet.dead;
      });
      if (this.tanks.length < 2) {
        return end_game();
      }
    };

    Game.prototype.integrate = function() {
      var bullet, tank, _i, _j, _len, _len1, _ref, _results;
      for (_i = 0, _len = bullets.length; _i < _len; _i++) {
        bullet = bullets[_i];
        bullet.x += bullet.vx * this.dt;
        bullet.y += bullet.vy * this.dt;
      }
      _ref = this.tanks;
      _results = [];
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        tank = _ref[_j];
        tank.fx -= tank.vx * 0.03;
        tank.fy -= tank.vy * 0.03;
        tank.vx += tank.fx * this.dt;
        tank.vy += tank.fy * this.dt;
        tank.x += tank.vx * this.dt + tank.fx * this.dt2;
        _results.push(tank.y += tank.vy * this.dt + tank.fy * this.dt2);
      }
      return _results;
    };

    Game.prototype.fire = function() {
      var bullet;
      if (tank.gun_heat <= tank.fire_command) {
        bullet = new Bullet(tank, tank.fire_command, tank.x, tank.y, tank.fx, tank.fy);
        tank.gun_heat += tank.fire_command;
        return this.bullets.push(bullet);
      } else {
        return tank.gun_heat -= this.dt;
      }
    };

    Game.prototype.resolve_collisions = function() {
      var bullet, dx, dy, tank, _i, _j, _len, _len1, _ref, _results;
      _results = [];
      for (_i = 0, _len = bullets.length; _i < _len; _i++) {
        bullet = bullets[_i];
        _ref = this.tanks;
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          tank = _ref[_j];
          if (bullet.tank !== tank) {
            dx = bullet.x - tank.x;
            dy = bullet.y - tank.y;
            if (dx * dx + dy * dy < tank.r + bullet.r) {
              bullet.dead = true;
              tank.life -= bullet.power;
              bullet.tank.score += bullet.power;
              break;
            }
          }
        }
        if (bullet.x * bullet.x + bullet.y * bullet.y >= this.r) {
          _results.push(bullet.dead = true);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Game.prototype.end_game = function() {
      return alert("End of game.");
    };

    return Game;

  })();

  Tank = (function() {

    function Tank() {}

    Tank.prototype.to_state = function(opponents, r) {
      return {
        x: this.x,
        y: this.y,
        radius: this.r,
        vx: this.vx,
        vy: this.vy,
        fx: 0.0,
        fy: 0.0,
        theta: this.theta,
        radar: opponents,
        arena_radius: r,
        gun_heat: this.gun_heat,
        life: this.life,
        score: this.score
      };
    };

    return Tank;

  })();

}).call(this);
