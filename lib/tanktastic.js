// Generated by CoffeeScript 1.3.3
(function() {
  var Bullet, DRAG, GAMMA, GaussRNG, HEIGHT, LOG_10, MAX_DBEARING, MAX_FIRE_POWER, MAX_ITERATIONS, MAX_SPEED, MAX_SPEED2, MIN_FIRE_POWER, MUZZLE_SPEED, Obstacle, Renderer, Tank, WIDTH, limit, rand, root;

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  root.tanktastic = {};

  WIDTH = 960;

  HEIGHT = 480;

  MAX_DBEARING = Math.PI;

  MAX_ITERATIONS = 10000;

  MIN_FIRE_POWER = 0.1;

  MAX_FIRE_POWER = 3.0;

  MAX_SPEED = 120.0;

  MAX_SPEED2 = MAX_SPEED * MAX_SPEED;

  DRAG = 0.05;

  MUZZLE_SPEED = 400;

  LOG_10 = Math.log(10);

  GAMMA = 1 / 3;

  limit = function(x, min, max) {
    return Math.max(min, Math.min(x, max));
  };

  rand = function(min, range) {
    return min + Math.random() * range;
  };

  GaussRNG = (function() {

    function GaussRNG() {
      this.v1 = this.v2 = this.s = this.phase = 0;
    }

    GaussRNG.prototype.random = function(mu, sigma) {
      var x;
      if (this.phase === 0) {
        while (true) {
          this.v1 = 2 * Math.random() - 1;
          this.v2 = 2 * Math.random() - 1;
          this.s = this.v1 * this.v1 + this.v2 * this.v2;
          if (!(this.s >= 1 || this.s === 0)) {
            break;
          }
        }
        x = this.v1 * Math.sqrt(-2 * Math.log(this.s) / this.s);
      } else {
        x = this.v2 * Math.sqrt(-2 * Math.log(this.s) / this.s);
      }
      this.phase = 1 - this.phase;
      return mu + sigma * x;
    };

    return GaussRNG;

  })();

  root.tanktastic.Game = (function() {

    Game.prototype.dt = 1 / 60;

    Game.prototype.dt2 = 1 / 3600;

    function Game(seed, graphics) {
      if (graphics == null) {
        graphics = null;
      }
      Math.seedrandom(seed);
      this.grng = new GaussRNG();
      this.tanks = [];
      this.bullets = [];
      this.build_obstacles();
      this.lt = 0;
      this.a = 0;
      this.iterations = 0;
      this.renderer = graphics ? new Renderer(graphics) : null;
    }

    Game.prototype.is_rendered = function() {
      return this.renderer !== null;
    };

    Game.prototype.is_complete = function() {
      var tank;
      return this.iterations >= MAX_ITERATIONS || ((function() {
        var _i, _len, _ref, _results;
        _ref = this.tanks;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          tank = _ref[_i];
          if (tank.life > 0) {
            _results.push(tank);
          }
        }
        return _results;
      }).call(this)).length < 2;
    };

    Game.prototype.podium = function() {
      return this.tanks.slice().sort(function(a, b) {
        if (a.ticks > b.ticks) {
          return 1;
        }
        if (a.ticks < b.ticks) {
          return -1;
        }
        if (a.life > b.life) {
          return 1;
        }
        if (a.life < b.life) {
          return -1;
        }
        return 0;
      });
    };

    Game.prototype.build_obstacles = function() {
      var num, _results;
      this.obstacles = [];
      num = 1 + Math.floor(Math.random() * 3);
      _results = [];
      while (this.obstacles.length < num) {
        _results.push(this.obstacles.push(new Obstacle(rand(30, 80), rand(WIDTH / 2 - 200, 400), rand(HEIGHT / 2 - 80, 160))));
      }
      return _results;
    };

    Game.prototype.register_tank = function(tank) {
      return this.tanks.push(new Tank(tank.name, tank.step, tank.init));
    };

    Game.prototype.obstacle_state = function() {
      var ob, _i, _len, _ref, _results;
      _ref = this.obstacles;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        ob = _ref[_i];
        _results.push({
          x: ob.x,
          y: ob.y,
          r: ob.r
        });
      }
      return _results;
    };

    Game.prototype.init = function() {
      var tank, _i, _len, _ref, _results;
      this.resolve_tank_obstacles(this.tanks);
      _ref = this.tanks;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        tank = _ref[_i];
        _results.push(tank.init(this.tanks.length - 1));
      }
      return _results;
    };

    Game.prototype.step = function(discrete) {
      var dt, now, tank, tanks, _i, _j, _len, _len1;
      if (discrete == null) {
        discrete = false;
      }
      tanks = this.tanks.filter(function(tank) {
        return tank.life > 0;
      });
      now = new Date().getTime();
      for (_i = 0, _len = tanks.length; _i < _len; _i++) {
        tank = tanks[_i];
        tank.hit = false;
      }
      if ((!discrete) && this.is_rendered()) {
        if (!(this.lt > 0)) {
          this.lt = now;
        }
        dt = (now - this.lt) / 1000.0;
        this.a = Math.min(this.a + dt, 1.0);
      } else {
        this.a = this.dt;
      }
      while (!(this.a < this.dt)) {
        for (_j = 0, _len1 = tanks.length; _j < _len1; _j++) {
          tank = tanks[_j];
          tank.step(this.dt, this.radar(tank, tanks), this.obstacle_state());
        }
        this.fire(tanks);
        this.integrate(tanks);
        this.resolve_collisions(tanks);
        this.bullets = this.bullets.filter(function(bullet) {
          return !bullet.dead;
        });
        this.a -= this.dt;
      }
      this.lt = discrete ? 0 : now;
      this.iterations++;
      if (this.is_rendered()) {
        return this.renderer.render(tanks, this.bullets, this.obstacles);
      }
    };

    Game.prototype.radar = function(tank, tanks) {
      var t, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = tanks.length; _i < _len; _i++) {
        t = tanks[_i];
        if (t !== tank) {
          _results.push(this.sensor(tank, t));
        }
      }
      return _results;
    };

    Game.prototype.sensor = function(scanner, tank) {
      var dist, dx, dy, sigma;
      dx = tank.x - scanner.x;
      dy = tank.y - scanner.y;
      dist = Math.max(Math.sqrt(dx * dx + dy * dy) - (tank.r + scanner.r), 1);
      sigma = GAMMA * Math.log(dist) / LOG_10;
      return {
        x: tank.x + this.grng.random(0, sigma),
        y: tank.y + this.grng.random(0, sigma)
      };
    };

    Game.prototype.render = function() {
      return this.renderer.render(this.tanks, this.bullets, this.obstacles);
    };

    Game.prototype.integrate = function(tanks) {
      var bullet, speed, tank, _i, _j, _len, _len1, _ref, _results;
      _ref = this.bullets;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        bullet = _ref[_i];
        bullet.x += bullet.vx * this.dt;
        bullet.y += bullet.vy * this.dt;
      }
      _results = [];
      for (_j = 0, _len1 = tanks.length; _j < _len1; _j++) {
        tank = tanks[_j];
        tank.fx -= tank.vx * DRAG;
        tank.fy -= tank.vy * DRAG;
        tank.vx += tank.fx * this.dt;
        tank.vy += tank.fy * this.dt;
        speed = tank.vx * tank.vx + tank.vy * tank.vy;
        if (speed > MAX_SPEED2) {
          speed = Math.sqrt(speed);
          tank.vx *= MAX_SPEED / speed;
          tank.vy *= MAX_SPEED / speed;
        }
        tank.x += tank.vx * this.dt;
        _results.push(tank.y += tank.vy * this.dt);
      }
      return _results;
    };

    Game.prototype.fire = function(tanks) {
      var bullet, tank, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = tanks.length; _i < _len; _i++) {
        tank = tanks[_i];
        if (tank.gun_heat <= 0) {
          bullet = new Bullet(tank, tank.fire_command);
          tank.gun_heat += tank.fire_command;
          _results.push(this.bullets.push(bullet));
        } else {
          _results.push(tank.gun_heat = Math.max(tank.gun_heat - this.dt, 0));
        }
      }
      return _results;
    };

    Game.prototype.resolve_collisions = function(tanks) {
      var bullet, dvx, dvy, dx, dy, hlen, i, impulse, j, len, len2, tank, ti, tj, _i, _j, _k, _len, _ref, _ref1, _ref2, _ref3, _results;
      for (i = _i = 0, _ref = tanks.length - 2; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        ti = tanks[i];
        for (j = _j = _ref1 = i + 1, _ref2 = tanks.length - 1; _ref1 <= _ref2 ? _j <= _ref2 : _j >= _ref2; j = _ref1 <= _ref2 ? ++_j : --_j) {
          tj = tanks[j];
          dx = tj.x - ti.x;
          dy = tj.y - ti.y;
          len2 = dx * dx + dy * dy;
          if (len2 <= (ti.r + tj.r) * (ti.r + tj.r)) {
            len = Math.sqrt(len2);
            dx /= len;
            dy /= len;
            dvx = tj.vx - ti.vx;
            dvy = tj.vy - ti.vy;
            impulse = -1 * (dvx * dx + dvy * dy);
            hlen = (ti.r + tj.r - len) / 2;
            ti.x -= dx * hlen;
            ti.y -= dy * hlen;
            tj.x += dx * hlen;
            tj.y += dy * hlen;
            ti.vx -= dx * impulse;
            ti.vy -= dy * impulse;
            tj.vx += dx * impulse;
            tj.vy += dy * impulse;
          }
        }
      }
      this.resolve_tank_obstacles(tanks);
      _ref3 = this.bullets;
      _results = [];
      for (_k = 0, _len = _ref3.length; _k < _len; _k++) {
        bullet = _ref3[_k];
        if (bullet.x > WIDTH || bullet.x < 0 || bullet.y < 0 || bullet.y > HEIGHT || this.does_collide(bullet)) {
          bullet.dead = true;
        }
        if (!!bullet.dead) {
          continue;
        }
        _results.push((function() {
          var _l, _len1, _results1;
          _results1 = [];
          for (_l = 0, _len1 = tanks.length; _l < _len1; _l++) {
            tank = tanks[_l];
            if (bullet.tank !== tank) {
              dx = bullet.x - tank.x;
              dy = bullet.y - tank.y;
              if (dx * dx + dy * dy <= (tank.r + bullet.r) * (tank.r + bullet.r)) {
                bullet.dead = true;
                tank.life -= bullet.power;
                tank.hit = true;
                bullet.tank.score += bullet.power;
                break;
              } else {
                _results1.push(void 0);
              }
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        })());
      }
      return _results;
    };

    Game.prototype.does_collide = function(bullet) {
      var dx, dy, obstacle, _i, _len, _ref;
      _ref = this.obstacles;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        obstacle = _ref[_i];
        dx = bullet.x - obstacle.x;
        dy = bullet.y - obstacle.y;
        if (dx * dx + dy * dy <= Math.pow(bullet.r + obstacle.r, 2)) {
          return true;
        }
      }
      return false;
    };

    Game.prototype.end_game = function() {
      return alert("End of game.");
    };

    Game.prototype.resolve_tank_obstacles = function(tanks) {
      var dvx, dvy, dx, dy, impulse, len, len2, obstacle, rsum, tank, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = tanks.length; _i < _len; _i++) {
        tank = tanks[_i];
        dx = 0;
        dy = 0;
        if (tank.x <= tank.r) {
          dx = tank.r - tank.x;
        }
        if (tank.x >= WIDTH - tank.r) {
          dx = (WIDTH - tank.r) - tank.x;
        }
        if (tank.y <= tank.r) {
          dy = tank.r - tank.y;
        }
        if (tank.y >= HEIGHT - tank.r) {
          dy = (HEIGHT - tank.r) - tank.y;
        }
        if (dx) {
          tank.x += dx;
          tank.vx *= -0.51;
        }
        if (dy) {
          tank.y += dy;
          tank.vy *= -0.51;
        }
        _results.push((function() {
          var _j, _len1, _ref, _results1;
          _ref = this.obstacles;
          _results1 = [];
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            obstacle = _ref[_j];
            dx = tank.x - obstacle.x;
            dy = tank.y - obstacle.y;
            len2 = dx * dx + dy * dy;
            rsum = tank.r + obstacle.r;
            if (len2 <= rsum * rsum) {
              len = Math.sqrt(len2);
              dx /= len;
              dy /= len;
              dvx = dx * tank.vx;
              dvy = dy * tank.vy;
              tank.x += dx * (rsum - len);
              tank.y += dy * (rsum - len);
              impulse = -1.51 * (dvx * dx + dvy * dy);
              if (impulse < 0) {
                tank.vx -= dx * impulse;
                _results1.push(tank.vy -= dy * impulse);
              } else {
                _results1.push(void 0);
              }
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    return Game;

  })();

  Tank = (function() {

    function Tank(name, step_target, init_target) {
      var rc;
      this.name = name;
      this.step_target = step_target;
      this.init_target = init_target;
      this.ticks = 0;
      this.r = 20;
      rc = Math.random() * 0xBB | (Math.random() * 0xBB) << 8 | (Math.random() * 0xBB) << 16;
      this.color = "#" + rc.toString(16);
      while (!(this.color.length > 6)) {
        this.color += "0";
      }
      this.x = Math.random() * (WIDTH - 2 * this.r);
      this.y = Math.random() * (HEIGHT - 2 * this.r);
      this.vx = this.vy = this.gun_heat = this.score = 0;
      this.life = 100;
      this.bearing = Math.random() * 2 * Math.PI;
    }

    Tank.prototype.init = function(num_tanks) {
      if (this.init_target) {
        return this.init_target(num_tanks);
      }
    };

    Tank.prototype.step = function(dt, radar, obstacles) {
      var controller, state, _ref;
      this.fx = this.fy = this.dbearing = 0;
      _ref = this.to_state(radar, obstacles), state = _ref[0], controller = _ref[1];
      this.step_target.apply(null, [dt, state, controller]);
      return this.ticks++;
    };

    Tank.prototype.to_state = function(radar, obstacles) {
      var controller, state, tank,
        _this = this;
      this.fx = this.fy = this.dbearing = 0.0;
      tank = this;
      controller = {
        set_bearing: function(bearing) {
          return tank.bearing = bearing;
        },
        exert: function(fx, fy) {
          tank.fx += fx;
          return tank.fy += fy;
        },
        fire: function(power) {
          return tank.fire_command = limit(power, MIN_FIRE_POWER, MAX_FIRE_POWER);
        },
        aim_at: function(x, y) {
          return tank.bearing = Math.atan2(y - _this.y, x - _this.x);
        }
      };
      state = {
        x: this.x,
        y: this.y,
        w: WIDTH,
        h: HEIGHT,
        radius: this.r,
        vx: this.vx,
        vy: this.vy,
        bearing: this.bearing,
        radar: radar,
        obstacles: obstacles,
        gun_heat: this.gun_heat,
        life: this.life,
        muzzle_speed: MUZZLE_SPEED,
        closest: function() {
          var dists;
          if (radar.length === 1) {
            return radar[0];
          }
          dists = radar.map((function(op) {
            return {
              dist: Math.pow(op.x - tank.x, 2) + Math.pow(op.y - tank.y, 2),
              op: op
            };
          }));
          return dists.sort(function(a, b) {
            return a.dist - b.dist;
          })[0].op;
        }
      };
      return [state, controller];
    };

    return Tank;

  })();

  Bullet = (function() {

    function Bullet(tank, power) {
      var i, j;
      this.tank = tank;
      this.power = power;
      i = Math.cos(this.tank.bearing);
      j = Math.sin(this.tank.bearing);
      this.r = 2 + this.power;
      this.power = Math.exp(this.power) - 1 / 3;
      this.x = this.tank.x + i * (tank.r + this.r - 6);
      this.y = this.tank.y + j * (tank.r + this.r - 6);
      this.vx = i * MUZZLE_SPEED;
      this.vy = j * MUZZLE_SPEED;
    }

    return Bullet;

  })();

  Obstacle = (function() {

    function Obstacle(r, x, y) {
      this.r = r;
      this.x = x;
      this.y = y;
    }

    return Obstacle;

  })();

  Renderer = (function() {

    function Renderer(graphics) {
      this.graphics = graphics;
    }

    Renderer.prototype.render = function(tanks, bullets, obstacles) {
      var bullet, obstacle, tank, _i, _j, _k, _len, _len1, _len2;
      this.graphics.clear();
      for (_i = 0, _len = obstacles.length; _i < _len; _i++) {
        obstacle = obstacles[_i];
        this.render_obstacle(obstacle);
      }
      for (_j = 0, _len1 = tanks.length; _j < _len1; _j++) {
        tank = tanks[_j];
        this.render_tank(tank);
      }
      for (_k = 0, _len2 = bullets.length; _k < _len2; _k++) {
        bullet = bullets[_k];
        this.render_bullet(bullet);
      }
      this.graphics.setStrokeStyle(4, "round");
      this.graphics.beginStroke("#000000");
      this.graphics.rect(0, 0, WIDTH, HEIGHT);
      return this.graphics.endStroke();
    };

    Renderer.prototype.render_obstacle = function(obstacle) {
      this.graphics.setStrokeStyle(4, "round");
      this.graphics.beginStroke("#000000");
      this.graphics.drawCircle(obstacle.x, obstacle.y, obstacle.r);
      return this.graphics.endStroke();
    };

    Renderer.prototype.render_bullet = function(bullet) {
      this.graphics.beginFill(bullet.tank.color);
      this.graphics.drawCircle(bullet.x, bullet.y, (2 + bullet.r) / 2);
      return this.graphics.endFill();
    };

    Renderer.prototype.render_tank = function(tank) {
      var cos, sin;
      this.graphics.setStrokeStyle(2, "round");
      this.graphics.beginStroke((tank.hit ? "#FF0000" : tank.color));
      this.graphics.drawCircle(tank.x, tank.y, tank.r);
      cos = Math.cos(tank.bearing);
      sin = Math.sin(tank.bearing);
      this.graphics.endStroke();
      this.graphics.setStrokeStyle(2, "round");
      this.graphics.beginStroke((tank.hit ? "#FF0000" : tank.color));
      this.graphics.moveTo(tank.x + -3 * cos - -3 * sin, tank.y + -3 * sin + -3 * cos);
      this.graphics.lineTo(tank.x + -3 * cos - 3 * sin, tank.y + -3 * sin + 3 * cos);
      this.graphics.lineTo(tank.x + (tank.r - 6) * cos - 3 * sin, tank.y + (tank.r - 6) * sin + 3 * cos);
      this.graphics.lineTo(tank.x + (tank.r - 6) * cos - -3 * sin, tank.y + (tank.r - 6) * sin + -3 * cos);
      this.graphics.lineTo(tank.x + -3 * cos - -3 * sin, tank.y + -3 * sin + -3 * cos);
      this.graphics.endStroke();
      return this.render_life(tank);
    };

    Renderer.prototype.render_life = function(tank) {
      var life;
      this.graphics.beginFill("#FFFFFF");
      this.graphics.rect(tank.x + 5, tank.y - 22, 22, 8);
      this.graphics.endFill();
      this.graphics.setStrokeStyle(1, "round");
      this.graphics.beginStroke(tank.color);
      this.graphics.rect(tank.x + 5, tank.y - 22, 22, 8);
      this.graphics.endStroke();
      this.graphics.beginFill(tank.color);
      life = Math.max(tank.life, 0);
      this.graphics.rect(tank.x + 7, tank.y - 20, 18 * life / 100, 4);
      return this.graphics.endFill();
    };

    return Renderer;

  })();

}).call(this);
